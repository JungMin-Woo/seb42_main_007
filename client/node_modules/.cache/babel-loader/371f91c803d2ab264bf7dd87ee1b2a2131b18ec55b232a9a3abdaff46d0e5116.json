{"ast":null,"code":"import { Plugin } from 'prosemirror-state';\nimport { findWrapping, canJoin } from 'prosemirror-transform';\n\n/**\r\nInput rules are regular expressions describing a piece of text\r\nthat, when typed, causes something to happen. This might be\r\nchanging two dashes into an emdash, wrapping a paragraph starting\r\nwith `\"> \"` into a blockquote, or something entirely different.\r\n*/\nclass InputRule {\n  // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\n  /**\r\n  Create an input rule. The rule applies when the user typed\r\n  something and the text directly in front of the cursor matches\r\n  `match`, which should end with `$`.\r\n  \r\n  The `handler` can be a string, in which case the matched text, or\r\n  the first matched group in the regexp, is replaced by that\r\n  string.\r\n  \r\n  Or a it can be a function, which will be called with the match\r\n  array produced by\r\n  [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\r\n  as well as the start and end of the matched range, and which can\r\n  return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the\r\n  rule's effect, or null to indicate the input was not handled.\r\n  */\n  constructor(\n  /**\r\n  @internal\r\n  */\n  match, handler) {\n    this.match = match;\n    this.match = match;\n    this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler;\n  }\n}\nfunction stringHandler(string) {\n  return function (state, match, start, end) {\n    let insert = string;\n    if (match[1]) {\n      let offset = match[0].lastIndexOf(match[1]);\n      insert += match[0].slice(offset + match[1].length);\n      start += offset;\n      let cutOff = start - end;\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert;\n        start = end;\n      }\n    }\n    return state.tr.insertText(insert, start, end);\n  };\n}\nconst MAX_MATCH = 500;\n/**\r\nCreate an input rules plugin. When enabled, it will cause text\r\ninput that matches any of the given rules to trigger the rule's\r\naction.\r\n*/\nfunction inputRules(_ref) {\n  let {\n    rules\n  } = _ref;\n  let plugin = new Plugin({\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, prev) {\n        let stored = tr.getMeta(this);\n        if (stored) return stored;\n        return tr.selectionSet || tr.docChanged ? null : prev;\n      }\n    },\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run(view, from, to, text, rules, plugin);\n      },\n      handleDOMEvents: {\n        compositionend: view => {\n          setTimeout(() => {\n            let {\n              $cursor\n            } = view.state.selection;\n            if ($cursor) run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin);\n          });\n        }\n      }\n    },\n    isInputRules: true\n  });\n  return plugin;\n}\nfunction run(view, from, to, text, rules, plugin) {\n  if (view.composing) return false;\n  let state = view.state,\n    $from = state.doc.resolve(from);\n  if ($from.parent.type.spec.code) return false;\n  let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, \"\\ufffc\") + text;\n  for (let i = 0; i < rules.length; i++) {\n    let match = rules[i].match.exec(textBefore);\n    let tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);\n    if (!tr) continue;\n    view.dispatch(tr.setMeta(plugin, {\n      transform: tr,\n      from,\n      to,\n      text\n    }));\n    return true;\n  }\n  return false;\n}\n/**\r\nThis is a command that will undo an input rule, if applying such a\r\nrule was the last thing that the user did.\r\n*/\nconst undoInputRule = (state, dispatch) => {\n  let plugins = state.plugins;\n  for (let i = 0; i < plugins.length; i++) {\n    let plugin = plugins[i],\n      undoable;\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        let tr = state.tr,\n          toUndo = undoable.transform;\n        for (let j = toUndo.steps.length - 1; j >= 0; j--) tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n        if (undoable.text) {\n          let marks = tr.doc.resolve(undoable.from).marks();\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n        } else {\n          tr.delete(undoable.from, undoable.to);\n        }\n        dispatch(tr);\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\r\nConverts double dashes to an emdash.\r\n*/\nconst emDash = new InputRule(/--$/, \"—\");\n/**\r\nConverts three dots to an ellipsis character.\r\n*/\nconst ellipsis = new InputRule(/\\.\\.\\.$/, \"…\");\n/**\r\n“Smart” opening double quotes.\r\n*/\nconst openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\");\n/**\r\n“Smart” closing double quotes.\r\n*/\nconst closeDoubleQuote = new InputRule(/\"$/, \"”\");\n/**\r\n“Smart” opening single quotes.\r\n*/\nconst openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\");\n/**\r\n“Smart” closing single quotes.\r\n*/\nconst closeSingleQuote = new InputRule(/'$/, \"’\");\n/**\r\nSmart-quote related input rules.\r\n*/\nconst smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];\n\n/**\r\nBuild an input rule for automatically wrapping a textblock when a\r\ngiven string is typed. The `regexp` argument is\r\ndirectly passed through to the `InputRule` constructor. You'll\r\nprobably want the regexp to start with `^`, so that the pattern can\r\nonly occur at the start of a textblock.\r\n\r\n`nodeType` is the type of node to wrap in. If it needs attributes,\r\nyou can either pass them directly, or pass a function that will\r\ncompute them from the regular expression match.\r\n\r\nBy default, if there's a node with the same type above the newly\r\nwrapped node, the rule will try to [join](https://prosemirror.net/docs/ref/#transform.Transform.join) those\r\ntwo nodes. You can pass a join predicate, which takes a regular\r\nexpression match and the node before the wrapped node, and can\r\nreturn a boolean to indicate whether a join should happen.\r\n*/\nfunction wrappingInputRule(regexp, nodeType) {\n  let getAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let joinPredicate = arguments.length > 3 ? arguments[3] : undefined;\n  return new InputRule(regexp, (state, match, start, end) => {\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    let tr = state.tr.delete(start, end);\n    let $start = tr.doc.resolve(start),\n      range = $start.blockRange(),\n      wrapping = range && findWrapping(range, nodeType, attrs);\n    if (!wrapping) return null;\n    tr.wrap(range, wrapping);\n    let before = tr.doc.resolve(start - 1).nodeBefore;\n    if (before && before.type == nodeType && canJoin(tr.doc, start - 1) && (!joinPredicate || joinPredicate(match, before))) tr.join(start - 1);\n    return tr;\n  });\n}\n/**\r\nBuild an input rule that changes the type of a textblock when the\r\nmatched text is typed into it. You'll usually want to start your\r\nregexp with `^` to that it is only matched at the start of a\r\ntextblock. The optional `getAttrs` parameter can be used to compute\r\nthe new node's attributes, and works the same as in the\r\n`wrappingInputRule` function.\r\n*/\nfunction textblockTypeInputRule(regexp, nodeType) {\n  let getAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return new InputRule(regexp, (state, match, start, end) => {\n    let $start = state.doc.resolve(start);\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) return null;\n    return state.tr.delete(start, end).setBlockType(start, start, nodeType, attrs);\n  });\n}\nexport { InputRule, closeDoubleQuote, closeSingleQuote, ellipsis, emDash, inputRules, openDoubleQuote, openSingleQuote, smartQuotes, textblockTypeInputRule, undoInputRule, wrappingInputRule };","map":{"version":3,"names":["Plugin","findWrapping","canJoin","InputRule","constructor","match","handler","stringHandler","string","state","start","end","insert","offset","lastIndexOf","slice","length","cutOff","tr","insertText","MAX_MATCH","inputRules","_ref","rules","plugin","init","apply","prev","stored","getMeta","selectionSet","docChanged","props","handleTextInput","view","from","to","text","run","handleDOMEvents","compositionend","setTimeout","$cursor","selection","pos","isInputRules","composing","$from","doc","resolve","parent","type","spec","code","textBefore","textBetween","Math","max","parentOffset","i","exec","dispatch","setMeta","transform","undoInputRule","plugins","undoable","getState","toUndo","j","steps","step","invert","docs","marks","replaceWith","schema","delete","emDash","ellipsis","openDoubleQuote","closeDoubleQuote","openSingleQuote","closeSingleQuote","smartQuotes","wrappingInputRule","regexp","nodeType","getAttrs","arguments","undefined","joinPredicate","attrs","Function","$start","range","blockRange","wrapping","wrap","before","nodeBefore","join","textblockTypeInputRule","node","canReplaceWith","index","indexAfter","setBlockType"],"sources":["C:/Users/Bo/Desktop/coding/codestates/my-app/seb42_main_007/client/node_modules/prosemirror-inputrules/dist/index.js"],"sourcesContent":["import { Plugin } from 'prosemirror-state';\r\nimport { findWrapping, canJoin } from 'prosemirror-transform';\r\n\r\n/**\r\nInput rules are regular expressions describing a piece of text\r\nthat, when typed, causes something to happen. This might be\r\nchanging two dashes into an emdash, wrapping a paragraph starting\r\nwith `\"> \"` into a blockquote, or something entirely different.\r\n*/\r\nclass InputRule {\r\n    // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\r\n    /**\r\n    Create an input rule. The rule applies when the user typed\r\n    something and the text directly in front of the cursor matches\r\n    `match`, which should end with `$`.\r\n    \r\n    The `handler` can be a string, in which case the matched text, or\r\n    the first matched group in the regexp, is replaced by that\r\n    string.\r\n    \r\n    Or a it can be a function, which will be called with the match\r\n    array produced by\r\n    [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\r\n    as well as the start and end of the matched range, and which can\r\n    return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the\r\n    rule's effect, or null to indicate the input was not handled.\r\n    */\r\n    constructor(\r\n    /**\r\n    @internal\r\n    */\r\n    match, handler) {\r\n        this.match = match;\r\n        this.match = match;\r\n        this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler;\r\n    }\r\n}\r\nfunction stringHandler(string) {\r\n    return function (state, match, start, end) {\r\n        let insert = string;\r\n        if (match[1]) {\r\n            let offset = match[0].lastIndexOf(match[1]);\r\n            insert += match[0].slice(offset + match[1].length);\r\n            start += offset;\r\n            let cutOff = start - end;\r\n            if (cutOff > 0) {\r\n                insert = match[0].slice(offset - cutOff, offset) + insert;\r\n                start = end;\r\n            }\r\n        }\r\n        return state.tr.insertText(insert, start, end);\r\n    };\r\n}\r\nconst MAX_MATCH = 500;\r\n/**\r\nCreate an input rules plugin. When enabled, it will cause text\r\ninput that matches any of the given rules to trigger the rule's\r\naction.\r\n*/\r\nfunction inputRules({ rules }) {\r\n    let plugin = new Plugin({\r\n        state: {\r\n            init() { return null; },\r\n            apply(tr, prev) {\r\n                let stored = tr.getMeta(this);\r\n                if (stored)\r\n                    return stored;\r\n                return tr.selectionSet || tr.docChanged ? null : prev;\r\n            }\r\n        },\r\n        props: {\r\n            handleTextInput(view, from, to, text) {\r\n                return run(view, from, to, text, rules, plugin);\r\n            },\r\n            handleDOMEvents: {\r\n                compositionend: (view) => {\r\n                    setTimeout(() => {\r\n                        let { $cursor } = view.state.selection;\r\n                        if ($cursor)\r\n                            run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin);\r\n                    });\r\n                }\r\n            }\r\n        },\r\n        isInputRules: true\r\n    });\r\n    return plugin;\r\n}\r\nfunction run(view, from, to, text, rules, plugin) {\r\n    if (view.composing)\r\n        return false;\r\n    let state = view.state, $from = state.doc.resolve(from);\r\n    if ($from.parent.type.spec.code)\r\n        return false;\r\n    let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, \"\\ufffc\") + text;\r\n    for (let i = 0; i < rules.length; i++) {\r\n        let match = rules[i].match.exec(textBefore);\r\n        let tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);\r\n        if (!tr)\r\n            continue;\r\n        view.dispatch(tr.setMeta(plugin, { transform: tr, from, to, text }));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n/**\r\nThis is a command that will undo an input rule, if applying such a\r\nrule was the last thing that the user did.\r\n*/\r\nconst undoInputRule = (state, dispatch) => {\r\n    let plugins = state.plugins;\r\n    for (let i = 0; i < plugins.length; i++) {\r\n        let plugin = plugins[i], undoable;\r\n        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\r\n            if (dispatch) {\r\n                let tr = state.tr, toUndo = undoable.transform;\r\n                for (let j = toUndo.steps.length - 1; j >= 0; j--)\r\n                    tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\r\n                if (undoable.text) {\r\n                    let marks = tr.doc.resolve(undoable.from).marks();\r\n                    tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\r\n                }\r\n                else {\r\n                    tr.delete(undoable.from, undoable.to);\r\n                }\r\n                dispatch(tr);\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\n/**\r\nConverts double dashes to an emdash.\r\n*/\r\nconst emDash = new InputRule(/--$/, \"—\");\r\n/**\r\nConverts three dots to an ellipsis character.\r\n*/\r\nconst ellipsis = new InputRule(/\\.\\.\\.$/, \"…\");\r\n/**\r\n“Smart” opening double quotes.\r\n*/\r\nconst openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\");\r\n/**\r\n“Smart” closing double quotes.\r\n*/\r\nconst closeDoubleQuote = new InputRule(/\"$/, \"”\");\r\n/**\r\n“Smart” opening single quotes.\r\n*/\r\nconst openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\");\r\n/**\r\n“Smart” closing single quotes.\r\n*/\r\nconst closeSingleQuote = new InputRule(/'$/, \"’\");\r\n/**\r\nSmart-quote related input rules.\r\n*/\r\nconst smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];\r\n\r\n/**\r\nBuild an input rule for automatically wrapping a textblock when a\r\ngiven string is typed. The `regexp` argument is\r\ndirectly passed through to the `InputRule` constructor. You'll\r\nprobably want the regexp to start with `^`, so that the pattern can\r\nonly occur at the start of a textblock.\r\n\r\n`nodeType` is the type of node to wrap in. If it needs attributes,\r\nyou can either pass them directly, or pass a function that will\r\ncompute them from the regular expression match.\r\n\r\nBy default, if there's a node with the same type above the newly\r\nwrapped node, the rule will try to [join](https://prosemirror.net/docs/ref/#transform.Transform.join) those\r\ntwo nodes. You can pass a join predicate, which takes a regular\r\nexpression match and the node before the wrapped node, and can\r\nreturn a boolean to indicate whether a join should happen.\r\n*/\r\nfunction wrappingInputRule(regexp, nodeType, getAttrs = null, joinPredicate) {\r\n    return new InputRule(regexp, (state, match, start, end) => {\r\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\r\n        let tr = state.tr.delete(start, end);\r\n        let $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs);\r\n        if (!wrapping)\r\n            return null;\r\n        tr.wrap(range, wrapping);\r\n        let before = tr.doc.resolve(start - 1).nodeBefore;\r\n        if (before && before.type == nodeType && canJoin(tr.doc, start - 1) &&\r\n            (!joinPredicate || joinPredicate(match, before)))\r\n            tr.join(start - 1);\r\n        return tr;\r\n    });\r\n}\r\n/**\r\nBuild an input rule that changes the type of a textblock when the\r\nmatched text is typed into it. You'll usually want to start your\r\nregexp with `^` to that it is only matched at the start of a\r\ntextblock. The optional `getAttrs` parameter can be used to compute\r\nthe new node's attributes, and works the same as in the\r\n`wrappingInputRule` function.\r\n*/\r\nfunction textblockTypeInputRule(regexp, nodeType, getAttrs = null) {\r\n    return new InputRule(regexp, (state, match, start, end) => {\r\n        let $start = state.doc.resolve(start);\r\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\r\n        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType))\r\n            return null;\r\n        return state.tr\r\n            .delete(start, end)\r\n            .setBlockType(start, start, nodeType, attrs);\r\n    });\r\n}\r\n\r\nexport { InputRule, closeDoubleQuote, closeSingleQuote, ellipsis, emDash, inputRules, openDoubleQuote, openSingleQuote, smartQuotes, textblockTypeInputRule, undoInputRule, wrappingInputRule };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}